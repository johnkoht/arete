#!/usr/bin/env tsx
/**
 * Build AGENTS.md from modular source files in .agents/sources/
 * 
 * Usage:
 *   npx tsx scripts/build-agents.ts dev   # Generate AGENTS.md for BUILD
 *   npx tsx scripts/build-agents.ts prod  # Generate dist/AGENTS.md for GUIDE
 * 
 * Targets:
 *   dev  - BUILD version (shared + builder) → AGENTS.md
 *   prod - GUIDE version (shared + guide) → dist/AGENTS.md
 */

import { readFile, writeFile, mkdir } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { existsSync } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const root = join(__dirname, '..');
const sourcesDir = join(root, '.agents', 'sources');

type Target = 'dev' | 'prod';

interface BuildConfig {
  target: Target;
  sourceFiles: string[];
  outputPath: string;
}

/**
 * Get build configuration based on target
 */
function getConfig(target: Target): BuildConfig {
  const sharedFiles = [
    'shared/vision.md',
    'shared/workspace-structure.md',
    'shared/cli-commands.md',
  ];

  const builderFiles = [
    'builder/skills-index.md',
    'builder/rules-index.md',
    'builder/conventions.md',
    'builder/memory.md',
  ];

  const guideFiles = [
    'guide/skills-index.md',
    'guide/tools-index.md',
    'guide/intelligence.md',
    'guide/workflows.md',
  ];

  if (target === 'dev') {
    return {
      target,
      sourceFiles: [...sharedFiles, ...builderFiles],
      outputPath: join(root, 'AGENTS.md'),
    };
  } else {
    return {
      target,
      sourceFiles: [...sharedFiles, ...guideFiles],
      outputPath: join(root, 'dist', 'AGENTS.md'),
    };
  }
}

/**
 * Read and concatenate source files with compression
 */
async function readSourceFiles(sourceFiles: string[]): Promise<string> {
  const contents: string[] = [];

  for (const file of sourceFiles) {
    const filePath = join(sourcesDir, file);
    
    if (!existsSync(filePath)) {
      console.warn(`Warning: Source file not found: ${file}`);
      continue;
    }

    try {
      const content = await readFile(filePath, 'utf-8');
      const compressed = compressContent(content, file);
      contents.push(compressed);
    } catch (error) {
      console.error(`Error reading ${file}:`, error);
      throw error;
    }
  }

  return contents.join('\n\n');
}

/**
 * Generate header with metadata and HOW TO USE section
 */
function generateHeader(sourceFiles: string[]): string {
  const timestamp = new Date().toISOString();
  const fileList = sourceFiles.map(f => `  - ${f}`).join('\n');

  return `# Areté - Product Builder's Operating System

<!-- Generated by build-agents.ts at ${timestamp} -->
<!-- DO NOT EDIT MANUALLY - Edit source files in .agents/sources/ -->
<!-- Source files:
${fileList}
-->

---

## HOW TO USE THIS INDEX

When a user asks for help with a PM task:
1. Scan the [Skills] section below for matching triggers
2. Read the skill file at the path shown
3. Follow the skill's workflow

Example: User says "help me prep for my meeting" → find meeting-prep in [Skills] → read .agents/skills/meeting-prep/SKILL.md

---
`;
}

/**
 * Compress skills table to pipe-delimited format
 */
function compressSkillsTable(content: string, rootPath: string): string {
  const lines = content.split('\n');
  const compressed: string[] = [`[Skills]|root:${rootPath}`];
  
  let inTable = false;
  for (const line of lines) {
    // Detect table start (header row)
    if (line.startsWith('| Skill |') || line.startsWith('||')) {
      inTable = true;
      continue;
    }
    
    // Skip separator row
    if (line.startsWith('|---')) {
      continue;
    }
    
    // Detect table end
    if (inTable && !line.startsWith('|')) {
      inTable = false;
      continue;
    }
    
    // Process table rows
    if (inTable && line.startsWith('|')) {
      const cells = line.split('|').map(c => c.trim()).filter(c => c);
      if (cells.length >= 4) {
        const [skill, , description, triggers] = cells;
        // Clean up markdown formatting
        const cleanSkill = skill.replace(/\*\*/g, '');
        const cleanDesc = description.replace(/\s+/g, ' ').trim();
        const cleanTriggers = triggers.replace(/"/g, '').trim();
        
        compressed.push(`|${cleanSkill}:{triggers:"${cleanTriggers}",does:"${cleanDesc}"}`);
      }
    }
  }
  
  return compressed.join('\n');
}

/**
 * Compress rules/tools list to pipe-delimited format
 */
function compressRulesList(content: string, rootPath: string, sectionName: string): string {
  const lines = content.split('\n');
  const compressed: string[] = [`[${sectionName}]|auto-applied:${rootPath}`];
  
  let inTable = false;
  for (const line of lines) {
    // Detect table start
    if (line.startsWith('| Rule |') || line.startsWith('|---')) {
      inTable = true;
      continue;
    }
    
    // Detect table end
    if (inTable && !line.startsWith('|')) {
      inTable = false;
      continue;
    }
    
    // Process table rows
    if (inTable && line.startsWith('|')) {
      const cells = line.split('|').map(c => c.trim()).filter(c => c);
      if (cells.length >= 3) {
        const [rule, , purpose] = cells;
        const cleanRule = rule.replace(/\*\*/g, '');
        const cleanPurpose = purpose.replace(/\s+/g, ' ').trim();
        
        compressed.push(`|${cleanRule}:${cleanPurpose}`);
      }
    }
  }
  
  return compressed.join('\n');
}

/**
 * Compress memory section
 */
function compressMemorySection(content: string): string {
  return `[Memory]|entry:memory/MEMORY.md
|before_work:scan MEMORY.md + collaboration.md
|after_work:add entry to memory/entries/, update index
|synthesis:synthesize-collaboration-profile skill after 5+ entries or PRD completion`;
}

/**
 * Compress CLI commands section
 */
function compressCLICommands(content: string): string {
  const lines = content.split('\n');
  const compressed: string[] = ['[CLI]'];
  
  let currentSection = '';
  for (const line of lines) {
    // Detect section headers
    if (line.startsWith('## ')) {
      currentSection = line.replace('## ', '').trim();
      continue;
    }
    
    // Capture command lines
    if (line.startsWith('- `arete ')) {
      const match = line.match(/`([^`]+)`\s*-\s*(.+)/);
      if (match) {
        const [, cmd, desc] = match;
        compressed.push(`|${cmd}:${desc.trim()}`);
      }
    }
  }
  
  return compressed.join('\n');
}

/**
 * Compress vision section
 */
function compressVision(content: string): string {
  return `[Vision]|Excellence (ἀρετή) for product builders
|question:"Does it help the product builder achieve arete?"
|achieve:gain clarity → navigate ambiguity → automate mundane → move faster → unlock opportunity → think better → challenge constructively`;
}

/**
 * Compress workspace structure
 */
function compressWorkspaceStructure(content: string): string {
  return `[Workspace]|two contexts: USER (installed) vs BUILD (this repo)
|user:now/ goals/ context/ projects/ resources/ .arete/ people/ templates/ .agents/skills/
|build:src/ runtime/ memory/ .agents/ dev/ .cursor/ test/ scripts/ bin/
|key_diff:memory/ at root (BUILD) vs .arete/memory/ (USER); .agents/skills/ = build skills (BUILD) vs product skills (USER)`;
}

/**
 * Apply compression to content based on section
 */
function compressContent(content: string, filename: string): string {
  // Skills index - compress heavily
  if (filename.includes('skills-index.md')) {
    const rootPath = filename.includes('builder') ? '.agents/skills' : 'runtime/skills';
    return compressSkillsTable(content, rootPath);
  }
  
  // Rules index - compress
  if (filename.includes('rules-index.md')) {
    return compressRulesList(content, '.cursor/rules/', 'Rules');
  }
  
  // Tools index - compress
  if (filename.includes('tools-index.md')) {
    return compressRulesList(content, 'runtime/tools/', 'Tools');
  }
  
  // Memory section - compress
  if (filename.includes('memory.md')) {
    return compressMemorySection(content);
  }
  
  // CLI commands - compress
  if (filename.includes('cli-commands.md')) {
    return compressCLICommands(content);
  }
  
  // Vision - compress heavily
  if (filename.includes('vision.md')) {
    return compressVision(content);
  }
  
  // Workspace structure - compress heavily
  if (filename.includes('workspace-structure.md')) {
    return compressWorkspaceStructure(content);
  }
  
  // Conventions - compress heavily
  if (filename.includes('conventions.md')) {
    return compressConventions(content);
  }
  
  // Intelligence - compress heavily
  if (filename.includes('intelligence.md')) {
    return compressIntelligence(content);
  }
  
  // Workflows - compress heavily
  if (filename.includes('workflows.md')) {
    return compressWorkflows(content);
  }
  
  // Default: minimal compression
  return content.trim();
}

/**
 * Compress conventions section
 */
function compressConventions(content: string): string {
  return `[Conventions]|TypeScript/Node.js build standards
|config:tsconfig.json (NodeNext, strict) + tsconfig.test.json
|imports:use .js extensions; import type for type-only
|types:prefer type over interface; no any/unknown; avoid as/!
|functions:function for top-level; arrow for callbacks
|naming:PascalCase (types), camelCase (vars/fns), UPPERCASE (constants), kebab-case (files)
|async:prefer async/await over Promises
|tests:node:test + node:assert/strict
|quality:npm run typecheck && npm test before commit
|execution:Tiny (1-2 steps) → direct; Small (2-3) → optional pre-mortem; Medium/Large (3+) → pre-mortem + PRD path recommended`;
}

/**
 * Compress intelligence services section
 */
function compressIntelligence(content: string): string {
  return `[Intelligence]|context+memory+resolution+briefing+routing
||context:arete context --for "query" → map primitives (Problem/User/Solution/Market/Risk) to workspace files
||memory:arete memory search "query" → search .arete/memory/ items (decisions, learnings); token or semantic (QMD)
||resolution:arete resolve "reference" → fuzzy match people, meetings, projects
||briefing:arete brief --for "query" → combine context+memory+entities
||routing:arete route "query" → match skill/tool, suggest tier (fast/balanced/powerful)
||synthesis:extract patterns/contradictions from project inputs
||inline_review:extract decisions during skill execution, immediate user approval before memory write
||qmd:optional semantic search via QMD (qmd search, vsearch, query)`;
}

/**
 * Compress workflows section
 */
function compressWorkflows(content: string): string {
  return `[Workflows]|common PM patterns
||week_start:quarter-plan → week-plan → daily-plan
||meeting:meeting-prep (before) → save-meeting (after) → process-meetings (extract)
||discovery:discovery skill → competitive-analysis → synthesize → create-prd
||project:create-prd → [work] → finalize-project → memory update
||review:periodic-review (workspace audit) → week-review (progress) → quarter retrospective
||onboard:onboarding tool (30/60/90) → learn/contribute/lead phases
||context:seed-context (bootstrap) → sync (ongoing) → pull (integrations)`;
}

/**
 * Validate source files for common issues before building
 */
async function validateSources(sourceFiles: string[]): Promise<void> {
  const errors: string[] = [];
  
  for (const file of sourceFiles) {
    const filePath = join(sourcesDir, file);
    
    if (!existsSync(filePath)) {
      continue; // Already handled in readSourceFiles
    }
    
    const content = await readFile(filePath, 'utf-8');
    
    // Check 1: Multi-IDE violations (either/or patterns)
    const eitherOrPattern = /\.cursor.*or.*\.claude|\.claude.*or.*\.cursor/i;
    if (eitherOrPattern.test(content)) {
      errors.push(`${file}: Contains "either/or" IDE path pattern (use only .cursor/ - adapter transforms it)`);
    }
    
    // Check 2: Direct .claude/ references (should use .cursor/ instead)
    const directClaudePattern = /\.claude\//;
    if (directClaudePattern.test(content) && !content.includes('adapter') && !content.includes('transform')) {
      errors.push(`${file}: Contains direct .claude/ reference (use .cursor/ instead - adapter transforms it)`);
    }
  }
  
  if (errors.length > 0) {
    console.error('\n❌ Validation failed:\n');
    errors.forEach(err => console.error(`  - ${err}`));
    console.error('\nFix these issues before building. See .agents/sources/README.md § Multi-IDE Consistency.\n');
    process.exit(1);
  }
}

/**
 * Build AGENTS.md for the specified target
 */
async function buildAgents(target: Target): Promise<void> {
  console.log(`Building AGENTS.md for target: ${target}`);

  // Get configuration
  const config = getConfig(target);
  console.log(`Output: ${config.outputPath}`);
  console.log(`Source files: ${config.sourceFiles.length}`);
  
  // Validate source files before building
  await validateSources(config.sourceFiles);

  // Ensure output directory exists
  const outputDir = dirname(config.outputPath);
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  // Read source files
  const content = await readSourceFiles(config.sourceFiles);

  // Generate header
  const header = generateHeader(config.sourceFiles);

  // Combine and write
  const output = header + content;
  await writeFile(config.outputPath, output, 'utf-8');

  // Report size
  const sizeKB = (output.length / 1024).toFixed(2);
  console.log(`✓ Generated ${config.outputPath} (${sizeKB} KB)`);

  // Warn if too large
  if (output.length > 10240) {
    console.warn(`⚠ Warning: Output size (${sizeKB} KB) exceeds 10 KB threshold`);
  }
}

/**
 * Main entry point
 */
async function main(): Promise<void> {
  const targetArg = process.argv[2] as Target | undefined;
  const target: Target = targetArg === 'prod' ? 'prod' : 'dev';

  if (targetArg && targetArg !== 'dev' && targetArg !== 'prod') {
    console.error(`Invalid target: ${targetArg}`);
    console.error('Usage: npx ts-node scripts/build-agents.ts [dev|prod]');
    process.exit(1);
  }

  try {
    await buildAgents(target);
  } catch (error) {
    console.error('Build failed:', error);
    process.exit(1);
  }
}

main();
