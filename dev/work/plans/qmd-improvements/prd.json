{
  "name": "qmd-improvements",
  "branchName": "feature/qmd-improvements",
  "goal": "Keep the qmd search index current automatically by triggering re-indexing after every CLI write operation, add a standalone `arete index` command for manual use, update agent rules for write-path awareness, and inject qmd into EntityService as a semantic pre-filter for meeting scans.",
  "userStories": [
    {
      "id": "task-1",
      "title": "Extract refreshQmdIndex() helper",
      "description": "Create a lightweight `refreshQmdIndex(workspaceRoot, existingCollectionName, deps?)` function in `packages/core/src/search/qmd-setup.ts`, separate from `ensureQmdCollection()`. This is the shared primitive used by all write-path commands. Uses the `testDeps` injection pattern (same as `ensureQmdCollection`) so tests never spawn real qmd processes. Also fix the stale `qmd-semantic-search` entry in `dev/catalog/capabilities.json` (wrong implementation paths).",
      "acceptanceCriteria": [
        "refreshQmdIndex(workspaceRoot, existingCollectionName, deps?) exported from packages/core/src/search/index.ts and @arete/core",
        "Skips gracefully (returns skipped:true) when qmd binary not on PATH",
        "Skips gracefully when existingCollectionName is undefined or empty",
        "Skips gracefully when ARETE_SEARCH_FALLBACK=1 env var is set",
        "Runs `qmd update` in workspaceRoot when all checks pass",
        "Returns { indexed: false, warning: string } on update failure — never throws",
        "Uses testDeps injection (whichSync + execFileAsync) — no real qmd processes in tests",
        "Unit tests cover all 5 cases above",
        "dev/catalog/capabilities.json qmd-semantic-search entry corrected",
        "npm run typecheck && npm test pass"
      ],
      "status": "complete",
      "passes": true,
      "attemptCount": 1,
      "commitSha": "dc29f35"
    },
    {
      "id": "task-2",
      "title": "Wire refreshQmdIndex() into write-path CLI commands",
      "description": "Add post-write re-indexing to `arete pull fathom`, `arete meeting add`, and `arete meeting process`. Each command calls `refreshQmdIndex()` after writing files, but only if files were actually written (count > 0).",
      "acceptanceCriteria": [
        "arete pull fathom triggers refreshQmdIndex() after saving meetings; skips if 0 new meetings saved",
        "arete meeting add triggers refreshQmdIndex() after saving; skips if meeting already existed",
        "arete meeting process triggers refreshQmdIndex() after writing person files; skips if nothing applied",
        "--skip-qmd flag added to pull fathom, meeting add, and meeting process subcommands",
        "meeting.ts adds loadConfig(services.storage, root) after findRoot()",
        "Output format: listItem / warn pattern",
        "npm run typecheck && npm test pass"
      ],
      "status": "complete",
      "passes": true,
      "attemptCount": 1,
      "commitSha": "0abfebb"
    },
    {
      "id": "task-3",
      "title": "Add `arete index` standalone command",
      "description": "Add a new top-level `arete index` command for users who add or edit files outside the CLI.",
      "acceptanceCriteria": [
        "arete index command registered in packages/cli/src/index.ts",
        "Default run: calls refreshQmdIndex(), shows 'Search index updated' if indexed",
        "arete index --status: prints collection name; does NOT run qmd update",
        "Graceful when qmd not installed or no collection configured",
        "Unit tests cover all 4 cases",
        "npm run typecheck && npm test pass"
      ],
      "status": "complete",
      "passes": true,
      "attemptCount": 1,
      "commitSha": "958d3d6"
    },
    {
      "id": "task-4",
      "title": "Update qmd-search.mdc rule for write-path awareness",
      "description": "Update both agent-facing qmd rule files to document the write-path indexing pattern.",
      "acceptanceCriteria": [
        "New 'After Writing Files' section added",
        "Both rule files updated and byte-for-byte identical",
        "diff produces zero output",
        "npm run typecheck && npm test pass"
      ],
      "status": "complete",
      "passes": true,
      "attemptCount": 1,
      "commitSha": "b30b4bb"
    },
    {
      "id": "task-5",
      "title": "Inject SearchProvider into EntityService",
      "description": "Add an optional `searchProvider?: SearchProvider` parameter to EntityService's constructor. In `refreshPersonMemory()`, use it to pre-filter which meeting files to scan per person.",
      "acceptanceCriteria": [
        "EntityService constructor: constructor(storage: StorageAdapter, searchProvider?: SearchProvider)",
        "All existing construction sites compile without modification",
        "When SearchProvider returns results: scans only matched file paths",
        "When SearchProvider returns 0 results: falls back to full scan",
        "Explicit test case: mock returning [] → full scan finds person",
        "No direct fs imports added",
        "npm run typecheck && npm test pass"
      ],
      "status": "complete",
      "passes": true,
      "attemptCount": 1,
      "commitSha": "d5bdeb9"
    },
    {
      "id": "task-6",
      "title": "Wire SearchProvider into EntityService via factory",
      "description": "Pass the SearchProvider instance from createServices() to EntityService.",
      "acceptanceCriteria": [
        "factory.ts: new EntityService(storage, search)",
        "All existing entity tests pass without modification",
        "New integration test: createServices() passes non-undefined SearchProvider to EntityService",
        "npm run typecheck && npm test pass"
      ],
      "status": "complete",
      "passes": true,
      "attemptCount": 1,
      "commitSha": "86755c4"
    },
    {
      "id": "task-r1",
      "title": "Fix refreshPersonMemory() — meeting cache, limit cap, path normalization",
      "description": "Three correctness and performance fixes to `EntityService.refreshPersonMemory()` identified in engineering lead review:\n\n1. PERFORMANCE: Add meeting content cache to eliminate O(people × meetings) reads in the no-SearchProvider path. Without cache, each meeting file is read once per person. A Map<string, string | null> populated lazily inside refreshPersonMemory() restores O(meetings) reads regardless of people count.\n\n2. CORRECTNESS: Raise limit from 20 to 100 (constant: SEARCH_PROVIDER_CANDIDATE_LIMIT = 100). Add fallback to full scan when results.length >= SEARCH_PROVIDER_CANDIDATE_LIMIT — same pattern as empty results — to prevent silent meeting drops for active workspaces.\n\n3. CORRECTNESS: Normalize paths from SearchProvider results before using them as storage.read() keys. The qmd provider runs with cwd=workspaceRoot and may return relative paths; storage.read() expects absolute paths. Use resolve(workspacePaths.root, r.path) which is a no-op for absolute paths and fixes relative ones.\n\nFiles to read first:\n- packages/core/src/services/entity.ts — refreshPersonMemory(), current limit:20 at line ~1180, personCandidateMeetings loop\n- packages/core/src/services/LEARNINGS.md — DI pattern, StorageAdapter invariant, empty-results→full-scan invariant\n- packages/core/test/services/person-memory.test.ts — existing SearchProvider test structure to extend\n- packages/core/src/search/types.ts — SearchProvider interface, SearchResult.path type",
      "acceptanceCriteria": [
        "Meeting content cache: Map<string, string | null> declared inside refreshPersonMemory(); all this.storage.read(meetingPath) calls in the per-person inner loop go through the cache; each meeting file read at most once regardless of people count",
        "Cache applies to BOTH the SearchProvider candidate path AND the no-provider full-scan path",
        "Limit constant: SEARCH_PROVIDER_CANDIDATE_LIMIT = 100 (named constant, not magic number) replaces limit:20",
        "Limit-overflow fallback: if results.length >= SEARCH_PROVIDER_CANDIDATE_LIMIT → treat same as empty results (full scan); add comment explaining the invariant",
        "Path normalization: resolve(workspacePaths.root, r.path) applied to each SearchProvider result path before storage use",
        "New test: mock SearchProvider returning exactly SEARCH_PROVIDER_CANDIDATE_LIMIT results → full scan executes (limit-overflow fallback)",
        "New test: mock SearchProvider returning a relative path ('resources/meetings/test.md') → person file is updated (path resolved correctly, storage.read succeeds)",
        "All existing person-memory.test.ts tests continue to pass",
        "npm run typecheck && npm test pass"
      ],
      "status": "pending",
      "passes": false,
      "attemptCount": 0
    },
    {
      "id": "task-r2",
      "title": "Extract displayQmdResult() helper + add clarifying comments",
      "description": "Two code quality improvements identified in engineering lead review:\n\n1. DEDUP: Extract the repeated QMD result display block (3 identical copies across pull.ts and meeting.ts ×2) into a shared helper function. The pattern:\n   if (qmdResult && !qmdResult.skipped) { if (qmdResult.indexed) listItem(...); if (qmdResult.warning) warn(...); }\n   appears verbatim in pull.ts, meeting.ts add, and meeting.ts process. Extract to a named function displayQmdResult(result: QmdRefreshResult | undefined): void in packages/cli/src/lib/qmd-output.ts (new file).\n\n2. COMMENTS: Add two clarifying comments in packages/core/src/search/qmd-setup.ts:\n   a. On the existingCollectionName parameter of refreshQmdIndex(): explain it's used as a 'qmd configured?' gate (if undefined/empty, skip) but is NOT passed to the qmd CLI — qmd infers the collection from the working directory (cwd: workspaceRoot).\n   b. Same clarification on the existingCollectionName parameter of ensureQmdCollection().\n\nFiles to read first:\n- packages/cli/src/commands/pull.ts — first occurrence of the display pattern (~L83)\n- packages/cli/src/commands/meeting.ts — two occurrences (~L145, ~L342)\n- packages/cli/src/formatters.ts — listItem() and warn() signatures to import in helper\n- packages/core/src/search/qmd-setup.ts — existingCollectionName parameters in refreshQmdIndex() and ensureQmdCollection()\n- packages/cli/src/commands/LEARNINGS.md — CLI patterns",
      "acceptanceCriteria": [
        "New file packages/cli/src/lib/qmd-output.ts with exported displayQmdResult(result: QmdRefreshResult | undefined): void",
        "displayQmdResult() handles all 3 states: indexed (shows listItem), warning (shows warn), skipped/undefined (no output)",
        "All 3 call sites in pull.ts and meeting.ts replaced with displayQmdResult(qmdResult)",
        "Import QmdRefreshResult from @arete/core in the new helper",
        "No behavior change — output identical to before",
        "packages/cli/src/lib/qmd-output.ts has unit test covering all 3 states (indexed, warning, skipped)",
        "Comment added to refreshQmdIndex() explaining existingCollectionName is a gate, not passed to qmd CLI",
        "Comment added to ensureQmdCollection() explaining existingCollectionName same way",
        "npm run typecheck && npm test pass"
      ],
      "status": "pending",
      "passes": false,
      "attemptCount": 0
    }
  ],
  "metadata": {
    "createdAt": "2026-02-21T22:30:00.000Z",
    "updatedAt": "2026-02-21T23:30:00.000Z",
    "totalTasks": 8,
    "completedTasks": 6,
    "failedTasks": 0,
    "phase2": "engineering-lead-review-fixes",
    "phase2AddedAt": "2026-02-21T23:30:00.000Z",
    "phase2Source": "engineering-lead-review",
    "phase2Tasks": ["task-r1", "task-r2"]
  }
}
