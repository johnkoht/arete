# Areté - Product Builder's Operating System

<!-- Generated by build-agents.ts at 2026-02-14T17:56:07.638Z -->
<!-- DO NOT EDIT MANUALLY - Edit source files in .agents/sources/ -->
<!-- Source files:
  - shared/vision.md
  - shared/workspace-structure.md
  - shared/cli-commands.md
  - builder/skills-index.md
  - builder/rules-index.md
  - builder/conventions.md
  - builder/memory.md
-->

---
# Areté Vision

**Areté** (ἀρετή) - Ancient Greek concept meaning "excellence" - the pursuit of fulfilling one's purpose to the highest degree.

Areté is a Product Management workspace that helps PMs streamline their workflows through structured context, project-based work, and institutional memory. The driving question behind every feature and design decision: **Does it help the product builder achieve arete?**

Product builders need clarity, understanding, vision, and strategy. They must navigate stakeholders, negotiate, inspire, and align. They synthesize signal from noise, make decisions under uncertainty, and benefit from structure that preserves institutional memory and sharpens judgment.

Areté exists so product builders have a workspace that elevates their practice: context that stays current, memory that persists, and workflows that reduce friction and sharpen thinking.

# Workspace Structure

## User Workspace (Installed)

```
your-workspace/
├── now/                     # Current focus (scratchpad, week, today, agendas)
├── goals/                   # Strategy and goals (strategy, quarter, initiatives)
├── context/                 # Core context (business, users, products, competitive)
├── projects/                # Project workspaces (active/, archive/)
├── resources/               # Raw inputs (meetings/, notes/)
├── .arete/                  # System-managed (memory/, activity/)
├── people/                  # People tracking (internal/, customers/, users/)
├── templates/               # Document templates
├── .agents/skills/          # PM workflows (discovery, PRD, meeting prep, etc.)
└── .cursor/ or .claude/     # IDE config (depends on install)
```

## Build Workspace (This Repo)

```
arete/                 # Build workspace root
├── src/               # Source code (core/, integrations/, cli/)
├── runtime/           # Files shipped to users (skills/, rules/, tools/)
├── memory/            # Build memory (MEMORY.md, collaboration.md, entries/)
├── .agents/           # Build-specific agent resources
│   ├── skills/        # Build skills (execute-prd, plan-to-prd, etc.)
│   └── sources/       # AGENTS.md source files
├── dev/               # Development tooling
│   ├── backlog/       # Future work (features/, improvements/)
│   ├── prds/          # PRDs for Areté features
│   └── autonomous/    # PRD execution templates
├── .cursor/           # Cursor IDE configuration (rules/, tools/)
├── test/              # Test files
├── scripts/           # Build and integration scripts
└── bin/               # Executable files (arete CLI)
```

**Key differences:**
- Build workspace has `memory/` at root; user workspace has `.arete/memory/`
- Build workspace has `.agents/skills/` for build skills; user workspace has product skills
- Build workspace has `dev/` directory for backlog, PRDs, autonomous tooling

# Essential CLI Commands

## Intelligence Services

- `arete route "<query>"` - Route user message to best skill and suggest model tier
- `arete skill route "<query>"` - Route to skill only (for agents before loading skill)
- `arete brief --for "task" --skill <name>` - Assemble primitive briefing (context + memory + entities)
- `arete context --for "query"` - Get relevant workspace files for a task
- `arete memory search "query"` - Search decisions, learnings, and observations
- `arete resolve "reference"` - Resolve ambiguous names (people, meetings, projects)

## People & Entities

- `arete people list` - List people (optional `--category internal|customers|users`)
- `arete people show <slug|email>` - Show person details

## Integrations

- `arete pull` - Sync from integrations (meetings, calendar)
- `arete pull calendar [--today|--days N]` - Pull calendar events
- `arete pull fathom [--days N]` - Pull Fathom recordings

## Workspace Management

- `arete status` - Check workspace health
- `arete update` - Update structure and rules
- `arete skill list` - List available skills
- `arete tool list` - List available tools

# Build Skills

Build skills live in `.agents/skills/` and are **not shipped to users**. They're for developing Areté itself. Read and follow these skills when doing the corresponding work.

| Skill | Path | Description | When to Use |
|-------|------|-------------|-------------|
| **execute-prd** | `.agents/skills/execute-prd/SKILL.md` | Autonomous PRD execution with Orchestrator (Sr. Eng Manager) and Reviewer (Sr. Engineer). Includes pre-mortem, structured feedback, and holistic review. | User says "Execute this PRD" or "Build everything in prd.json"; multi-task PRDs with dependencies (3+ tasks); want autonomous execution with quality review |
| **plan-to-prd** | `.agents/skills/plan-to-prd/SKILL.md` | Convert an approved plan into a PRD, prd.json, and handoff prompt for autonomous execution via execute-prd. | User chose "Convert to PRD" when offered the PRD path in Plan Mode; after plan-pre-mortem rule offers the choice and user selects the PRD path |
| **prd-to-json** | `.agents/skills/prd-to-json/SKILL.md` | Convert markdown PRD to JSON task list for autonomous execution. Reads build memory for context. | "Convert this PRD to JSON", "Create prd.json from [PRD file]", "Prepare PRD for autonomous execution"; after creating a PRD for an Areté feature you want to build autonomously |
| **prd-post-mortem** | `.agents/skills/prd-post-mortem/SKILL.md` | Systematic post-mortem analysis after PRD execution. Analyzes outcomes, extracts learnings, synthesizes subagent reflections, and creates memory entry. | After completing a PRD via execute-prd skill; user says "Create the post-mortem" or "Extract learnings from this PRD"; at end of PRD execution before closing |
| **review-plan** | `.agents/skills/review-plan/SKILL.md` | Structured second-opinion review for plans, PRDs, or completed work. Applies checklist and devil's advocate perspective. | "Review this plan", "Can you give me a second opinion on this?", "Critique this PRD"; when one agent creates work and another should evaluate it; before executing complex or high-stakes work |
| **run-pre-mortem** | `.agents/skills/run-pre-mortem/SKILL.md` | Run a pre-mortem risk analysis before starting multi-step work. Identifies risks across 8 categories and creates actionable mitigations. | Before executing approved plans (3+ steps or complex); before large refactors (touching many files); before new systems (integrations, providers, etc.) |
| **synthesize-collaboration-profile** | `.agents/skills/synthesize-collaboration-profile/SKILL.md` | Review build entries' Learnings and Corrections, merge into memory/collaboration.md, and update the builder collaboration profile. | Builder asks to "Synthesize collaboration profile" or "Update collaboration from entries"; after PRD post-mortem; after several entries with learnings have accumulated (5+); after major build phase or quarterly review |

## How to Use

Read the skill file with the Read tool, then follow its workflow. These skills are not in the `<available_skills>` list because they're workspace-specific (not user-global).

## Skill Triggers

- Plan review requested → read `.agents/skills/review-plan/SKILL.md`
- PRD execution starting → read `.agents/skills/execute-prd/SKILL.md`
- Pre-mortem needed → read `.agents/skills/run-pre-mortem/SKILL.md`
- PRD completed → read `.agents/skills/prd-post-mortem/SKILL.md`
- Plan → PRD conversion → read `.agents/skills/plan-to-prd/SKILL.md`
- Convert PRD to JSON → read `.agents/skills/prd-to-json/SKILL.md`
- Update collaboration profile → read `.agents/skills/synthesize-collaboration-profile/SKILL.md`

# Build Rules

Build rules in `.cursor/rules/` define standards and workflows for developing Areté itself.

| Rule | Path | Purpose |
|------|------|---------|
| **arete-vision.mdc** | `.cursor/rules/arete-vision.mdc` | Product philosophy — "Does it help the product builder achieve arete?" Guides all feature and design decisions. |
| **dev.mdc** | `.cursor/rules/dev.mdc` | Core development practices: build skills, build memory, execution path decision tree, quality practices, TypeScript/Node.js conventions, Python conventions, pre-mortem guidelines, skill/rule change checklist, multi-IDE consistency, documentation planning. |
| **testing.mdc** | `.cursor/rules/testing.mdc` | Testing requirements: all code changes must include tests. TypeScript tests (`node:test` + `node:assert/strict`), Python tests (`unittest`), test structure (Arrange-Act-Assert), test mapping, quality gates (typecheck + test:all). |
| **agent-memory.mdc** | `.cursor/rules/agent-memory.mdc` | Memory management for AI agents building Areté: memory locations (entries, collaboration.md, MEMORY.md), when to create entries, when to synthesize collaboration profile, how to leverage build memory before starting work. |
| **plan-pre-mortem.mdc** | `.cursor/rules/plan-pre-mortem.mdc` | Mandatory pre-mortem workflow when in Plan Mode or creating multi-step plans. Includes PRD gateway: offer PRD path for plans with 3+ steps, new systems, integrations, or large refactors. |

## Usage

These rules are automatically applied when working in the Areté build context (BUILDER mode). They inform agent behavior for:

- **arete-vision.mdc** — Always applied; informs every decision
- **dev.mdc** — Code changes, refactors, new features
- **testing.mdc** — All code changes (mandatory test coverage)
- **agent-memory.mdc** — Memory capture, collaboration profile updates
- **plan-pre-mortem.mdc** — Multi-step plans, complex work, PRD execution

## Related Content

- Build skills: `.agents/sources/builder/skills-index.md`
- Build conventions: `.agents/sources/builder/conventions.md`
- Build memory: `.agents/sources/builder/memory.md`

# Build Conventions

Standards for building and changing Areté. Testing is covered in `testing.mdc`; this document covers code style, quality practices, and commit workflows.

## TypeScript / Node.js

### Configuration

- **Config**: `tsconfig.json` (NodeNext, strict mode)
- **Tests**: `tsconfig.test.json`
- **Module Resolution**: NodeNext (requires `.js` extensions in imports)

### Code Style

**Imports:**
- Use `.js` extensions for local modules (NodeNext resolution)
- Use `import type` when a symbol is only used as a type
- Example: `import { someFunction } from '../../src/core/module.js';`

**Variables:**
- Prefer `const`/`let`; avoid `var`
- Use strict equality (`===`, `!==`)
- No unused variables
- Use optional chaining (`?.`) and nullish coalescing (`??`) where they clarify intent

**Types:**
- Prefer `type` over `interface` except for public API contracts
- Avoid `any` and `unknown`
- Avoid `as` or `!` unless necessary (e.g. known-safe casts after validation)
- No implicit any (strict TypeScript)

**Functions:**
- Use `function` keyword for top-level/named functions
- Arrow functions for callbacks and short inline use
- Descriptive names (verbs + nouns, e.g. `getUserData`)
- Use default parameters and destructuring where it improves readability

**Naming Conventions:**
- PascalCase for types/classes
- camelCase for variables, functions, methods
- UPPERCASE for constants and environment-related names
- Files/directories: kebab-case

**Code Structure:**
- Prefer functional, declarative code
- Avoid classes unless stateful encapsulation is needed
- Use constants for magic numbers and repeated values
- Iterate and modularize rather than duplicating

**Async:**
- Prefer `async`/`await` over raw Promises

**Security:**
- Use environment variables (or `.credentials`/config) for secrets
- Validate and sanitize CLI inputs and file paths
- Avoid executing user-controlled strings as shell commands

**Tests:**
- `node:test` + `node:assert/strict`
- See `testing.mdc` for full testing requirements

## Python

**Location:** `scripts/integrations/`

**Tests:** `test_*.py` in same directory

**Style:**
- unittest framework
- Mock external I/O with `unittest.mock`
- See `testing.mdc` for runner and patterns

## Linting / Formatting

No ESLint or Prettier in the repo yet. For now:
- Match existing style in the file (indent, quotes, semicolons)
- Run `npm run typecheck` and `npm test` / `npm run test:all` before committing

If you add ESLint or Prettier, document config and scripts in dev.mdc and MEMORY.md.

## Quality Practices

These practices apply to **all development work**, not just PRD execution. Scale them based on work size.

### 1. Pre-mortem (recommended for 3+ steps or complex work)

**When:** Before starting work that has risk (new systems, integrations, refactors, 3+ dependent tasks)

**How:**
- Use standalone skill: `.agents/skills/run-pre-mortem/SKILL.md`
- Or use template: `dev/autonomous/templates/PRE-MORTEM-TEMPLATE.md`
- Work through 8 risk categories (context gaps, test patterns, integration, scope creep, code quality, dependencies, platform issues, state tracking)
- Create concrete mitigations for each risk

**Skip when:** Single-file changes, trivial updates, well-understood patterns

### 2. Second opinion review (optional)

**When:** Before executing a plan or PRD, especially when:
- The work is complex or high-stakes
- You want a different agent/model to review before proceeding
- Audience (builder vs user) isn't obvious

**How:**
- Use skill: `.agents/skills/review-plan/SKILL.md`
- Reviewer applies checklist and provides devil's advocate perspective

**Skip when:** Trivial changes, well-understood work, time-sensitive fixes

### 3. Quality gates (mandatory for ALL commits)

Before any commit:

```bash
npm run typecheck  # Must pass
npm test           # Must pass (full suite)
```

If the work touches Python (`scripts/integrations/`):

```bash
npm run test:py
```

**No exceptions** — even for "quick fixes." Quality gates catch ripple effects.

### 4. Code review checklist

Apply before committing:

- [ ] Uses `.js` extensions in imports (NodeNext resolution)
- [ ] No `any` types (strict TypeScript)
- [ ] Proper error handling (try/catch with graceful fallback)
- [ ] Tests for happy path and edge cases
- [ ] Backward compatibility preserved (unless explicitly breaking)
- [ ] Follows project patterns (see existing code)

### 5. Build memory capture (after substantial work)

**When:** After work that meets any of these criteria:
- Modifies 3+ files
- Takes substantial time
- Introduces new patterns or architectural changes
- Encounters surprising issues or learnings

**How:**
1. Create entry: `memory/entries/YYYY-MM-DD_[short-name]-learnings.md`
2. Include: what changed, what worked, what didn't, learnings, corrections
3. Add index line to `memory/MEMORY.md`

**Skip when:** Trivial changes (typo fixes, comment updates), no learnings to capture

See `memory.md` for full memory workflow.

### 6. Reuse and avoid duplication

Before implementing new helpers, services, or abstractions:
- Check if equivalent functionality exists in `src/core/`, `src/integrations/`, or existing modules
- Search AGENTS.md for existing patterns
- Apply DRY (Don't Repeat Yourself)
- Apply KISS (Keep It Simple)

If you find repetitive logic that isn't abstracted, create a refactor backlog item in `dev/backlog/improvements/` — but don't block on it.

### 7. Skill and rule changes (mandatory review)

Before creating or modifying any skill or rule file:

**Checklist:**
- [ ] Re-read `dev.mdc` before making changes
- [ ] Audience check: BUILD (dev/, .cursor/) or PRODUCT (runtime/)?
- [ ] Skill table: If adding a build skill, add to dev.mdc skills table
- [ ] AGENTS.md: Update if skill/rule changes architecture or workflows
- [ ] Cross-references: Search for references to the skill/rule being changed

**Why:** Skills and rules define agent behavior. Changes propagate widely.

### 8. Multi-IDE consistency check

Before editing files in `runtime/rules/`, `runtime/tools/`, or any path affecting both Cursor and Claude:

**Checklist:**
- [ ] No "either/or" paths: Use only `.cursor/X` (adapter transforms it)
- [ ] No hardcoded IDE names in content
- [ ] Check adapter transforms: Claude does `.cursor/` → `.claude/` and `.mdc` → `.md`

**Reference:** `src/core/adapters/claude-adapter.ts`

## Execution Path Decision Tree

When approving a plan (in Plan Mode or otherwise):

```
User approves plan
     |
     ├─ Tiny (1-2 simple steps: fix typo, add comment, update string)
     |  → Direct execution
     |  → Quality gates (typecheck + test) ✓
     |  → Skip pre-mortem, skip memory capture
     |
     ├─ Small (2-3 moderate steps: add function + tests, refactor module)
     |  → Ask: "Run pre-mortem first? (Recommended for new features)"
     |  → Direct execution (with optional pre-mortem)
     |  → Quality gates ✓
     |  → Offer: "Capture learnings?" at end
     |
     └─ Medium/Large (3+ steps OR complex: new system, integration, refactor)
        → Strongly recommend: "PRD path or direct execution?"
        → If PRD: Load .agents/skills/plan-to-prd/SKILL.md
        → If direct: Apply pre-mortem + quality gates + memory capture
```

**When in doubt:** Offer both paths and let builder choose.

## Commit Message Format

Use conventional commit format:

- `feat:` — New feature
- `fix:` — Bug fix
- `refactor:` — Code change that neither fixes a bug nor adds a feature
- `test:` — Adding or updating tests
- `docs:` — Documentation changes
- `chore:` — Maintenance tasks

Example: `feat: add builder AGENTS.md source files`

## Before Committing

1. `npm run typecheck`
2. `npm run test:all` (or `npm test` + `npm run test:py`)
3. New code → new/updated tests
4. Code review checklist (see above)

## Documentation Planning

When creating plans that touch code/features/structure, ask: **"Does this need doc updates?"**

**Scope Check:**
- [ ] All root docs: README, SETUP, AGENTS, ONBOARDING, scratchpad
- [ ] Backlog items: Search for explicit doc requirements

**Search Strategy:**
- [ ] Feature keywords: `rg "keyword1|keyword2" -g "*.md"`
- [ ] Concept audit: If feature changes paths/structure, grep old paths
- [ ] Related workflows: Check files that reference setup, install, or getting started

**Anti-pattern:** Don't assume "documentation" = README + SETUP + AGENTS. ONBOARDING, scratchpad, and backlog frequently need updates.

## References

- **Testing:** `.cursor/rules/testing.mdc`
- **Build memory:** `memory/MEMORY.md`, `.agents/sources/builder/memory.md`
- **Node/TS conventions:** Informed by [Cursor Directory Node.js rules](https://cursor.directory/rules/node.js)

# Build Memory

Institutional knowledge for developing Areté. This system helps you work effectively with the builder and avoid repeating mistakes.

## Memory Locations

| Content | Location |
|---------|----------|
| Architecture decisions, refactors, tooling changes | `memory/entries/YYYY-MM-DD_slug.md` |
| Collaboration observations (in entry Learnings section) | `memory/entries/YYYY-MM-DD_slug.md` |
| Synthesized builder collaboration profile | `memory/collaboration.md` |
| Index of all entries | `memory/MEMORY.md` |
| "Park this for later" | `scratchpad.md` |

**Do not** write to `memory/items/` or `.arete/memory/` — those are product templates for end users.

## Leverage Build Memory

Before substantive work:

1. **Read `memory/collaboration.md`** — patterns, preferences, and Corrections to avoid repeat mistakes
2. **Scan `memory/MEMORY.md`** — recent entries relevant to your task
3. **Read specific entries** if the task relates to a documented decision or pattern

This prevents repeating mistakes and ensures you work in a way the builder prefers.

## When to Create Entries

Create an entry (`memory/entries/YYYY-MM-DD_slug.md`) after work that meets any of these criteria:

- Refactors (especially multi-file or architectural)
- Tooling changes (test setup, build scripts, CLI commands)
- Architectural decisions (new patterns, file structure changes)
- Breaking changes or migrations
- Fixes worth remembering (subtle bugs, gotchas)
- Anything you'd want to remember in 6 months

**Entry format:** `YYYY-MM-DD_slug.md` (e.g. `2026-02-13_dev-cleanup-phase-1-learnings.md`)

## Entry Structure

Each entry should include:

### Required Sections

- **What changed** — Brief summary of the work completed
- **What worked well** — Patterns to repeat (e.g., "Parallel subagent execution for simple moves")
- **What didn't work** — Patterns to avoid (e.g., "Assumed docs scope without checking backlog")
- **Learnings for next time** — Concrete improvements (e.g., "Add documentation planning checklist to dev.mdc")

### Optional Sections

- **Learnings / Collaboration Patterns** — How the builder works, preferences, corrections
- **Learnings / Corrections (for collaboration.md)** — Explicit corrections to apply to the collaboration profile
- **Execution Path** — Which execution path was used (Direct / PRD / Direct + pre-mortem)
- **Pre-mortem effectiveness** — Risks identified vs. risks materialized
- **Metrics** — Tasks completed, tests added, files changed, token usage

### Learnings Section (Collaboration)

If you noticed collaboration patterns during the work, include them in a **Learnings** section:

```markdown
## Learnings

### Collaboration Patterns

- **Builder preference:** [observation about how builder likes to work]
- **Corrections:** [if builder corrected you, document here]
- **What worked:** [interaction patterns that went well]
- **What didn't work:** [patterns to avoid]
```

These observations feed into `memory/collaboration.md` via the `synthesize-collaboration-profile` skill.

## Index Updates

After creating an entry, add a line to `memory/MEMORY.md` (top of Index section):

```markdown
- YYYY-MM-DD [Title](entries/YYYY-MM-DD_slug.md) — one-line summary
```

## Entries vs Scratchpad vs Backlog

| Content | Location | Examples |
|---------|----------|----------|
| **What happened** — decisions, changes, learnings | `memory/entries/` | Refactors, architectural decisions, methodology findings |
| **Raw or underdeveloped ideas** | `scratchpad.md` | "We should eventually build onboarding"; quick capture, parking lot |
| **Mature future work** — discussed, with a plan | `dev/backlog/` | Idea + general plan, enough detail to become a PRD |

**Do not** put backlog items or future work in entries. Entries record what was decided or done; scratchpad and backlog record what might be done.

## Collaboration Profile (collaboration.md)

`memory/collaboration.md` is a synthesized profile of how to work with the builder, derived from **Learnings** sections in entries.

### When to Synthesize

Run `.agents/skills/synthesize-collaboration-profile/SKILL.md` when:

1. **Builder asks** — "Synthesize collaboration profile", "Update collaboration from entries"
2. **After PRD post-mortem** — prd-post-mortem skill suggests synthesis
3. **Several entries with Learnings** — 5+ new entries include Learnings or Corrections sections
4. **After major build phase** — Large feature complete, multi-PRD run done
5. **Periodic** — Monthly or every 10 entries with Learnings

**Do not** synthesize after every single entry; batch so the profile evolves in coherent passes.

### What Goes in collaboration.md

- Builder's working style and preferences
- Communication patterns (e.g., "Prefers brief summaries over detailed explanations")
- Corrections from previous mistakes
- Task breakdown preferences
- Documentation preferences
- Quality standards and expectations

### How It's Used

At the start of new build conversations, agents read `memory/collaboration.md` to immediately understand how to work with the builder. This creates continuity across sessions.

## Auto-Capture Corrections

When the builder corrects you during a session:

1. **Automatically add to the entry's Learnings section** (don't ask)
2. **If this is a recurring correction**, mark it for `memory/collaboration.md`
3. **Document under "Learnings / Corrections"** in the entry

This ensures corrections are captured and fed into the collaboration profile.

## Prompt to Add Memory

After a notable refactor, tooling change, architectural decision, or fix worth remembering, **ask the builder:**

> "Should I add this to build memory (memory/MEMORY.md)?"

If yes, create a dated entry and add a line to the index. Include a **Learnings** section if you noticed collaboration patterns during the session.

## Execution Path Tracking

In each memory entry, include a brief "Execution Path" section:

```markdown
## Execution Path
- **Size assessed**: Small / Medium / Large
- **Path taken**: Direct / Direct + pre-mortem / PRD
- **Decision tree followed?**: Yes / No / Partially
- **Notes**: (e.g., "Builder chose direct over recommended PRD")
```

This creates a lightweight audit trail for execution path decisions.

## Examples

See `memory/entries/` for real examples of well-structured entries:

- `2026-02-13_dev-cleanup-phase-1-learnings.md` — Comprehensive PRD execution learning
- `2026-02-13_multi-ide-path-fix.md` — Bug fix with architectural implications
- `2026-02-13_quality-practices-abstraction.md` — Methodology change with pre-mortem analysis

## References

- **Full memory guidance:** `.cursor/rules/agent-memory.mdc`
- **Memory index:** `memory/MEMORY.md`
- **Collaboration profile:** `memory/collaboration.md`
- **Synthesize skill:** `.agents/skills/synthesize-collaboration-profile/SKILL.md`